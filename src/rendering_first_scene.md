# Render a Mesh

*Bevy’s default plugin set already includes the OBJ loader.*

<br>

Load a Truck-generated OBJ, set up a camera and a couple of lights, and render it with Bevy.

OBJ files are generated by sibling crates (`truck_brep/output/` or `truck_meshes/output/`). Bevy only watches the viewer’s `assets/` directory, so either copy or (preferably) symlink those OBJ files into `truck_viewer/assets/`. Symlinks keep hot reload working without duplicating files.

From `truck_workspace/`, link the outputs into the viewer assets (adjust names if needed):

```bash
mkdir truck_viewer/assets

ln -snf ../../truck_brep/output   truck_viewer/assets/brep_output
ln -snf ../../truck_meshes/output truck_viewer/assets/mesh_output
```

Then load paths like `brep_output/mesh.obj` or `mesh_output/mesh.obj` from Bevy (relative to `assets/`).

> Windows note: creating symlinks may require Developer Mode or admin permission; if symlinks aren’t available, copy the OBJ files into `truck_viewer/assets/` instead.

## Imports and main

Start from the empty window example and add:

- A 3D camera pointing at the origin.
- A directional light plus some ambient light.
- A PBR mesh loaded from your Truck-generated OBJ.

Update `truck_viewer/src/lib.rs` (or `src/app.rs` if you keep it split) so the library builds the app, then keep `src/main.rs` as the tiny runner that calls `truck_viewer::run()` (same as the previous section).

`truck_viewer/src/lib.rs`

```rust
use bevy::prelude::*;
use bevy::asset::RenderAssetUsages;
use bevy::render::render_resource::PrimitiveTopology;

pub fn build_app() -> App {
    let mut app = App::new();
    app.add_plugins(DefaultPlugins.set(WindowPlugin {
        primary_window: Some(Window {
            title: "Truck mesh with Bevy".into(),
            ..Default::default()
        }),
        ..Default::default()
    }))
    .add_systems(Startup, setup);
    app
}

pub fn run() {
    build_app().run();
}

fn setup(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    commands.insert_resource(ClearColor(Color::srgb(0.06, 0.06, 0.08)));
    commands.insert_resource(AmbientLight {
        color: Color::WHITE,
        brightness: 0.2,
        affects_lightmapped_meshes: true,
    });

    // Basic camera
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(5.0, 4.0, 5.0).looking_at(Vec3::new(0.0, 1.0, 0.0), Vec3::Y),
    ));

    // White headlight + gentle fill
    commands.spawn((
        DirectionalLight {
            shadows_enabled: true,
            illuminance: 8_000.0,
            ..Default::default()
        },
        Transform::from_xyz(1.0, -1.0, -1.0).looking_at(Vec3::ZERO, Vec3::Y),
    ));

    // Load an OBJ exported from Truck (e.g., teapot.obj or cube.obj).
    let mesh_handle = meshes.add(load_obj_mesh("assets/brep_output/cube.obj"));
    let material = materials.add(StandardMaterial {
        base_color: Color::srgb(0.78, 0.78, 0.78),
        perceptual_roughness: 0.35,
        metallic: 0.05,
        ..Default::default()
    });

    commands.spawn((Mesh3d(mesh_handle), MeshMaterial3d(material), Transform::default()));
}

fn load_obj_mesh(path: &str) -> Mesh {
    let (models, _) = tobj::load_obj(
        path,
        &tobj::LoadOptions {
            triangulate: true,
            single_index: true,
            ..Default::default()
        },
    )
    .expect("failed to load obj");

    let mesh = &models[0].mesh;
    let mut bevy_mesh = Mesh::new(PrimitiveTopology::TriangleList, RenderAssetUsages::RENDER_WORLD);
    let mut positions: Vec<[f32; 3]> = Vec::with_capacity(mesh.indices.len());
    let mut normals: Vec<[f32; 3]> = Vec::new();
    let mut uvs: Vec<[f32; 2]> = Vec::new();

    for &i in &mesh.indices {
        let idx = i as usize;
        let pos = [
            mesh.positions[3 * idx],
            mesh.positions[3 * idx + 1],
            mesh.positions[3 * idx + 2],
        ];
        positions.push(pos);

        if !mesh.normals.is_empty() {
            normals.push([
                mesh.normals[3 * idx],
                mesh.normals[3 * idx + 1],
                mesh.normals[3 * idx + 2],
            ]);
        }

        if !mesh.texcoords.is_empty() {
            uvs.push([mesh.texcoords[2 * idx], mesh.texcoords[2 * idx + 1]]);
        }
    }

    bevy_mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    if !normals.is_empty() {
        bevy_mesh.insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    }
    if !uvs.is_empty() {
        bevy_mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    }
    bevy_mesh
}

```

`truck_viewer/src/main.rs` stays:

```rust
fn main() {
    truck_viewer::run();
}
```

Replace `"output/mesh.obj"` with any OBJ generated in previous chapters (remember it should live under `assets/`). Bevy will hot-reload assets placed in `assets/` when the `file_watcher` feature is enabled.

Run a watcher to reload when OBJ files change in either output folder:

```bash
cargo watch \
  -w truck_brep/output \
  -w truck_meshes/output \
  -x "run -p truck_viewer"
```

This rebuilds/reruns the viewer whenever an OBJ changes in `truck_brep/output` or `truck_meshes/output`; Bevy picks up the linked/copied files under `truck_viewer/assets/`.

## Run

```bash
cargo run --bin viewer
```

A lit, shaded version of your mesh should appear immediately.

<details>
<summary>Complete files (after this step)</summary>

`truck_viewer/src/lib.rs`

```rust
use bevy::prelude::*;

pub fn build_app() -> App {
    let mut app = App::new();
    app.add_plugins(DefaultPlugins.set(WindowPlugin {
        primary_window: Some(Window {
            title: "Truck mesh with Bevy".into(),
            ..Default::default()
        }),
        ..Default::default()
    }))
    .add_systems(Startup, setup);
    app
}

pub fn run() {
    build_app().run();
}

fn setup(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    commands.insert_resource(ClearColor(Color::srgb(0.06, 0.06, 0.08)));
    commands.insert_resource(AmbientLight {
        color: Color::WHITE,
        brightness: 0.2,
    });

    commands.spawn(Camera3dBundle {
        transform: Transform::from_xyz(5.0, 4.0, 5.0)
            .looking_at(Vec3::new(0.0, 1.0, 0.0), Vec3::Y),
        ..Default::default()
    });

    commands.spawn(DirectionalLightBundle {
        directional_light: DirectionalLight {
            shadows_enabled: true,
            illuminance: 8_000.0,
            ..Default::default()
        },
        transform: Transform::from_xyz(1.0, -1.0, -1.0).looking_at(Vec3::ZERO, Vec3::Y),
        ..Default::default()
    });

    let mesh_handle: Handle<Mesh> = asset_server.load("output/mesh.obj");
    let material = materials.add(StandardMaterial {
        base_color: Color::srgb(0.78, 0.78, 0.78),
        perceptual_roughness: 0.35,
        metallic: 0.05,
        ..Default::default()
    });

    commands.spawn(PbrBundle {
        mesh: mesh_handle,
        material,
        ..Default::default()
    });
}
```

`truck_viewer/src/main.rs`

```rust
fn main() {
    truck_viewer::run();
}
```
</details>

<details>
<summary>Target directory tree (after this step)</summary>

```
truck_viewer/
├── Cargo.toml
├── assets/
│   ├── brep_output -> ../truck_brep/output   # symlink 
│   └── mesh_output -> ../truck_meshes/output # symlink
└── src/
    ├── lib.rs
    └── main.rs
    ├── app.rs        # sets up plugins, cameras, lights
    └── sync.rs       # sync editor state <-> bevy world
```
</details>
